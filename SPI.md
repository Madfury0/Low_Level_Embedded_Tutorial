### **Week 2, Day 2: SPI Protocol and Sensor Interfacing**  
**Objective**: Learn SPI (Serial Peripheral Interface) fundamentals, configure SPI registers for master mode, and interface with an SPI sensor (e.g., temperature sensor).  

---

### **1. SPI Protocol Basics**  
#### **Key Concepts**:  
1. **SPI Features**:  
   - **Full-duplex, synchronous serial communication** (Master ↔ Slave).  
   - **Signals**:  
     - **SCK**: Serial clock (generated by master).  
     - **MOSI**: Master Out Slave In (data to slave).  
     - **MISO**: Master In Slave Out (data from slave).  
     - **CS/SS**: Chip Select (slave enable, active low).  
   - **Modes**: Determined by **CPOL** (clock polarity) and **CPHA** (clock phase).  
     - Mode 0: CPOL=0 (SCK idle low), CPHA=0 (data sampled on rising edge).  
     - Mode 3: CPOL=1 (SCK idle high), CPHA=1 (data sampled on falling edge).  

2. **SPI Data Frame**:  
   - 8-bit or 16-bit data transfers.  
   - MSB-first or LSB-first (configurable).  

---

### **2. SPI Registers (STM32F4 Example)**  
#### **SPI1 Registers** (Base Address: `0x40013000`):  
- **CR1 (Control Register 1)**:  
  - `CPHA`, `CPOL`, `MSTR` (master mode), `SPE` (SPI enable), `BR[2:0]` (baud rate prescaler).  
- **CR2 (Control Register 2)**:  
  - `DS[3:0]` (data size: 0x3 for 8-bit, 0xF for 16-bit).  
- **SR (Status Register)**:  
  - `TXE` (transmit buffer empty), `RXNE` (receive buffer not empty).  
- **DR (Data Register)**:  
  - Write to transmit, read to receive.  

---

### **3. Lab: Read Temperature from SPI Sensor (MAX31855)**  
**Task**: Configure SPI1 to read temperature data from a MAX31855 thermocouple sensor.  

#### **Sensor Details**:  
- **SPI Mode**: Mode 0 (CPOL=0, CPHA=0).  
- **Data Format**: 32-bit frame (temperature + fault flags).  

#### **Code Steps**:  
1. **Enable Clocks**:  
   ```c
   // Enable GPIOA (PA5=SCK, PA6=MISO, PA7=MOSI) and SPI1
   RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;  
   RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;  
   ```  

2. **Configure GPIO Pins** (Alternate Function AF5):  
   ```c
   // PA5 (SCK), PA7 (MOSI) as AF5
   GPIOA->MODER   |=  GPIO_MODER_MODER5_1 | GPIO_MODER_MODER7_1;  
   GPIOA->AFR[0]  |=  (5 << (5 * 4)) | (5 << (7 * 4)); // AF5 for SPI1  

   // PA6 (MISO) as input
   GPIOA->MODER   |=  GPIO_MODER_MODER6_0;  
   ```  

3. **Configure SPI1 (Master Mode, 8-bit data)**:  
   ```c
   SPI1->CR1 = SPI_CR1_MSTR |              // Master mode  
               SPI_CR1_BR_0 |              // Baud rate = f_PCLK/4  
               SPI_CR1_SSI |               // Software CS management  
               SPI_CR1_SSM |               // Disable hardware CS  
               SPI_CR1_SPE;                // Enable SPI  

   SPI1->CR2 = SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2; // 8-bit data  
   ```  

4. **Read Temperature**:  
   ```c
   // Assert CS (e.g., PA4 as GPIO output)
   GPIOA->ODR &= ~(1 << 4); // Pull CS low  

   // Send dummy byte to trigger data transfer
   SPI1->DR = 0xFF;  
   while (!(SPI1->SR & SPI_SR_RXNE)); // Wait for RX  
   uint32_t data = SPI1->DR;          // Read first byte  

   // Read remaining 3 bytes (repeat 3x)
   // ...  

   // De-assert CS
   GPIOA->ODR |= (1 << 4); // Pull CS high  

   // Extract temperature (bits 18-31 in 14-bit format)
   int16_t temp = (data >> 18) & 0x3FFF;  
   temp = temp / 4; // Convert to °C  
   ```  

---

### **4. Homework: Send 16-bit Data Over SPI**  
**Task**: Write a function to transmit a 16-bit value over SPI1.  

#### **Solution Code**:  
```c
void SPI_Send16(uint16_t data) {  
    // Configure SPI1 for 16-bit mode  
    SPI1->CR2 = SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2 | SPI_CR2_DS_3;  

    // Wait until TX buffer is empty  
    while (!(SPI1->SR & SPI_SR_TXE));  

    // Send data  
    SPI1->DR = data;  

    // Wait until RX buffer is full (data received)  
    while (!(SPI1->SR & SPI_SR_RXNE));  
    volatile uint16_t dummy = SPI1->DR; // Clear RXNE flag  
}  
```  

---

### **5. Key Takeaways**  
- **SPI Modes**: CPOL/CPHA must match the slave device.  
- **CS Management**: Handle CS manually (GPIO) unless hardware CS is used.  
- **Data Size**: Use `CR2` to set 8-bit or 16-bit frames.  

### **Common Pitfalls**:  
- Forgetting to de-assert CS after transmission.  
- Not waiting for `TXE`/`RXNE` flags, leading to data corruption.  
- Incorrect GPIO alternate function configuration.  

---

### **6. Real-World Example: SPI Sensor Initialization**  
Many sensors require setup commands before reading data. For example:  
```c
// Send "Start Conversion" command to a sensor  
void Sensor_StartConversion(void) {  
    GPIOA->ODR &= ~(1 << 4); // CS low  
    SPI_Send16(0x8000);       // Command: Start conversion  
    GPIOA->ODR |= (1 << 4);  // CS high  
}  
```  

---

**Next**: Day 3 will cover I2C protocol and EEPROM interfacing.
